{#-
# Services related exported variables
#
# most important are:
#   - ldap_*
#   - services: a dict name / state to apply of enabled services
#   - selection: all avalaible services with their detected activation status
#      - ssh is enabled by default
#      - ntp can't run in lxc containers
#      - ldap has to be toggled on
#}

{%- import "makina-states/_macros/nodetypes.jinja" as nodetypes with context %}
{%- import "makina-states/_macros/controllers.jinja" as controllers with context %}
{#-
# expose imported macros
#}
{%- set nodetypes = nodetypes %}
{%- set localsettings = nodetypes.localsettings %}
{%- set funcs = localsettings.funcs %}
{%- set ldap = localsettings.ldap %}
{%- set saltmac = controllers.saltmac %}
{%- set kind = funcs.servicesKind %}
{%- set statesPref = funcs.statesPref + kind + '.' %}
{%- set grainsPref = funcs.grainsPref + kind + '.' %}
{%- set bases = ['localsettings'] %}
{#-
# SSL Settings
#}
{%- set SSLSettings = localsettings.SSLSettings %}

{#- -----------------------------------------------------
# LDAP integration
#}
{%- set ldapVariables = ldap.ldapVariables %}
{%- set ldapEn = ldap.ldapEn %}

{#- -----------------------------------------------------
# init systems flags
#}
{%- set upstart = salt['mc_utils.get']('makina-states.upstart', False) %}

{#- -----------------------------------------------------
# ntp is not applied to LXC containers ! (services.base.ntp)
# So we will just match when our grain is set and not have a value of lxc
#}
{%- set ntpEn = (
  not (
    ('dockercontainer' in nodetypes.registry['actives'])
    or ('lxccontainer' in nodetypes.registry['actives'])
  )) %}

{#- -----------------------------------------------------
# Pureftpd:  (services.ftp.pureftpd)
#}
{%- set pureftpdDefaultSettings = salt['mc_utils.defaults'](
  'makina-states.services.ftp.pureftpdefaults', {
    'Virtualchroot'      : 'false',
    'InetdMode'          : 'standalone',
    'UploadUid'          : '',
    'UploadGid'          : '',
    'UploadScript'       : '',
  }) %}
{%- set pureftpdSettings = salt['mc_utils.defaults'](
  'makina-states.services.ftp.pureftp', {
    'AllowAnonymousFXP'  : 'no',
    'AllowDotFiles'      : '',
    'AllowUserFXP'       : '',
    'AltLog'             : 'clf:/var/log/pure-ftpd/transfer.log',
    'AnonymousBandwidth' : '',
    'AnonymousCanCreateDirs': 'no',
    'AnonymousCantUpload': 'yes',
    'AnonymousOnly'      : '',
    'AnonymousRatio'     : '',
    'AntiWarez'          : '',
    'AutoRename'         : '',
    'Bind'               : '',
    'BrokenClientsCompatibility': 'yes',
    'CallUploadScript'   : '',
    'ChrootEveryone'     : 'yes',
    'ClientCharset'      : '',
    'Daemonize'          : "",
    'DisplayDotFiles'    : "yes",
    'DontResolve'        : "yes",
    'FSCharset'          : 'utf-8',
    'IPV4Only'           : "yes",
    'IPV6Only'           : "",
    'KeepAllFiles'       : "no",
    'LimitRecursion'     : "5000 500",
    'LogPID'             : "",
    'MaxClientsNumber'   : "",
    'MaxClientsPerIP'    : "",
    'MaxDiskUsage'       : "90",
    'MinUID'             : '1000',
    'NATmode'            : "",
    'NoAnonymous'        : 'yes',
    'NoChmod'            : "",
    'NoRename'           : "",
    'NoTruncate'         : "",
    'Quota'              : "",
    'SyslogFacility'     : "",
    'TLS'                : "1",
    'TrustedGID'         : "",
    'TrustedIP'          : "",
    'Umask'              : "133 022",
    'UserBandwidth'      : "",
    'UserRatio'          : "",
    'VerboseLog'         : "yes",

    'PassiveIP'          : "",
    'PassivePortRange'   : "",

    'PAMAuthentication'  : 'yes',
    'UnixAuthentication' : 'no',
    'PureDB'             : '/etc/pure-ftpd/pureftpd.pdb',
    'MySQLConfigFile'    : "",
    'ExtAuth'            : "",
    'LDAPConfigFile'     : "",
    'PGSQLConfigFile'    : "",
    }) %}
{%- for setting in pureftpdSettings %}
{%-   do pureftpdSettings.update({setting: pureftpdSettings[setting]+'\n'}) %}
{%- endfor %}

{#- -----------------------------------------------------
# PostGRESQL:  (services.db.postgresql)
# default user: makina-states.services.postgresql.user
#}
{%- set postgresqlUser = salt['mc_utils.get']('makina-states.services.postgresql.user', 'postgres') %}
{#-
# default postgresql/ grains configured databases (see service doc)
#}
{%- set pgDbs = {} %}
{%- for dbk, data in pillar.items() %}
{%-   if dbk.endswith('-makina-postgresql') %}
{%-     set db = data.get('name', dbk.split('-makina-postgresql')[0]) %}
{%-     do pgDbs.update({db: data}) %}
{%-   endif %}
{%- endfor %}
{#-
# default postgresql/ grains configured users (see service doc)
#}
{%- set postgresqlUsers = {} %}
{%- for userk, data in pillar.items() %}
{%-   if userk.endswith('-makina-services-postgresql-user') %}
{%-     do postgresqlUsers.update({user: data}) %}
{%-   endif %}
{%- endfor %}

{#-
# default activated postgresql versions:
#}
{%- set defaultPgVersion = salt['mc_utils.get'](
   'makina-states.services.postgresql.version',
   '9.3') %}
{%- set pgVers = salt['mc_utils.get'](
   'makina-states.services.postgresql.versions',
   [defaultPgVersion]) %}
{%- set postgisVers = salt['mc_utils.get'](
   'makina-states.services.postgis.versions',
   {'2.1': [defaultPgVersion, '9.2']}) %}
{%- set postgisDbName = salt['mc_utils.get'](
  'makina-states.services.postgis.dbname', 'postgis') %}

{#- -----------------------------------------------------
# MySQL default custom configuration (services.db.mysql)
# To override the default makina-states configuration file,
# Use the 'makina-states.services.mysql.cnf pillar/grain
#}
{%- set myCnf = salt['mc_utils.get'](grainsPref+'mysql.cnf', None) %}
{#- Set this to true to disable mysql automatic configuration
# (if you want to call the mysql macros yourself
# (makina-states.services.mysql.noautoconf)
#}
{%- set myDisableAutoConf = salt['mc_utils.get'](grainsPref+'mysql.noautoconf', False) %}

{#- -----------------------------------------------------
# shorewall pillar parsing
#}
{%- set shw_enabled = (
   salt['mc_utils.get'](grainsPref+'shorewall.enabled', False)) %}
{%- set shwIfformat = 'FORMAT 2' %}
{%- if grains['os'] not in ['Debian']%}
{%-  set shwIfformat = '?' %}
{%- endif %}
{%- set shwPolicies = [] %}
{%- set shwZones = {} %}
{%- set shwInterfaces = {} %}
{%- set shwParams = {} %}
{%- set shwMasqs = {} %}
{%- set shwRules= {} -%}
{%- set shwDefaultState = 'new' -%}
{%- set shwData = {
  'interfaces' : shwInterfaces,
  'rules'      : shwRules,
  'params'     : shwParams,
  'policies'   : shwPolicies,
  'zones'      : shwZones,
  'masqs'      : shwMasqs,
  'ifformat'   : shwIfformat,
} %}
{%- for sid, shorewall in pillar.items() -%}
{%-  if sid.endswith('makina-shorewall') -%}
{%-    set _shwlocrules = shorewall.get('rules', {}) -%}
{%-    for i in _shwlocrules-%}
{%-      set section = i.get('section', shwDefaultState).upper() -%}
{%-      if section not in shwRules -%}
{%-        do shwRules.update({section: []}) -%}
{%-      endif -%}
{%-      do shwRules[section].append(i) -%}
{%-    endfor -%}
{%-    do shwInterfaces.update(shorewall.get('interfaces', {})) %}
{%-    do shwMasqs.update(shorewall.get('masqs', {})) %}
{%-    do shwParams.update(shorewall.get('params', {})) %}
{%-    do shwZones.update(shorewall.get('zones', {})) -%}
{%-    do shwPolicies.extend(shorewall.get('policies', [])) %}
{%-  endif %}
{%- endfor %}

{#-
# SSH/SSHD Settings
#}
{% set sshServerSettings = salt['mc_utils.defaults'](
    'makina-states.services.ssh.server', {
      'AuthorizedKeysFile': '.ssh/authorized_keys .ssh/authorized_keys2',
      'ChallengeResponseAuthentication': 'no',
      'X11Forwarding': 'yes',
      'PrintMotd': 'no',
      'UsePrivilegeSeparation': 'sandbox',
      'Banner': '/etc/ssh/banner',
      'UsePAM': 'yes',
    }) %}
{% set sshClientSettings =  salt['mc_utils.defaults'](
    'makina-states.services.ssh.client', {
      'StrictHostKeyChecking': 'no',
      'UserKnownHostsFile': '/dev/null',
      'AddressFamily': 'any',
      'ConnectTimeout': 0,
      'SendEnv': "LANG: LC_*",
      'HashKnownHosts': 'yes',
      'GSSAPIAuthentication': 'yes',
      'GSSAPIDelegateCredentials': 'no',
    }) %}

{#-
# AUTOPOSTGRESQL BACKUPS
#}
{%- set autopostgresqlbackupSettings = salt['mc_utils.defaults'](
    'makina-states.services.backup.autopostgresql', {
      "PG_BACKUP_DIR" : "/srv/backups/pgsql",
      "DBNAMES"       : "all",
      "MAILCONTENT"   : "log",
      "MAXATTSIZE"    : 4000,
      "MAILADDR"      : "root@localhost",
      "DBEXCLUDES"    : "",
      "MDBNAMES"      : "",
      "DOWEEKLY"      : "6",
      "OPT"           : "-Fc",
    }) %}
{%- set autopostgresqlbackupGlobalSettings = autopostgresqlbackupSettings.copy() %}
{%- do autopostgresqlbackupGlobalSettings.update({
    "OPT"           : "--globals-only",
    "DBNAMES"       : "postgres template0 template1",
}) %}

{#- -----------------------------------------------------
# REGISTRY
# -----------------------------------------------------
# Idea is to map each state file to configure a service to it's particular
# configuration grain switch (or pillar)
#}
{%- set registryConfiguration = {
  kind: {
    'states_pref': statesPref, 'grains_pref': grainsPref,
    'defaults': {
      'base.ssh': {'active': True},
      'base.ntp': {'active': ntpEn},
      'backup.bacula-fd': {'active': False},
      'backup.astrailssafe': {'active': False},
      'db.mysql': {'active': False},
      'db.postgresql': {'active': False},
      'ftp.pureftpd': {'active': False},
      'firewall.shorewall': {'active': False},
      'gis.qgis': {'active': False},
      'gis.postgis': {'active': False},
      'http.apache': {'active': False},
      'java.solr4': {'active': False},
      'java.tomcat7': {'active': False},
      'mail.dovecot': {'active': False},
      'mail.postfix': {'active': False},
      'php.common': {'active': False},
      'php.modphp': {'active': False},
      'php.phpfpm': {'active': False},
      'php.phpfpm_with_apache': {'active': False},
      'virt.docker': {'active': False},
      'virt.docker-shorewall': {'active': False},
      'virt.lxc': {'active': False},
      'virt.lxc-shorewall': {'active': False},
    }
  }
} %}
{%- set registry = funcs.getRegistries(registryConfiguration)[kind] %}

{% macro autoinclude(name) %}
{{funcs.autoinclude(registry, bases=bases) }}
{% endmacro %}

{% macro register(name, data=None) %}
{{ funcs.register(statesPref, grainsPref, name, data=None) }}
{% endmacro %}

{% macro unregister(name, data=None) %}
{{ funcs.register(statesPref, grainsPref, name, data=None) }}
{% endmacro %}
# vim:set nofoldenable:
