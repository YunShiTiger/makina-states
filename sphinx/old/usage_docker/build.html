

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Docker &mdash; Makina States 1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Makina States 1.0 documentation" href="../../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> Makina States</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>
<ul class="simple">
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Custom states modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/modules/index.html">Execution modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/states/index.html">States modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/grains/index.html">makina-states grains modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/api/index.html">Api  modules</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../v1/index.html">Makina-states V1 documentation (OBSOLETE)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../v1/index.html#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v1/index.html#reference">Reference</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Makina States</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
    <li>Docker</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/old/usage_docker/build.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="docker">
<span id="build-docker"></span><h1>Docker<a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h1>
<div class="section" id="intro">
<h2>Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Although we are all on the container &amp; microservices front,
the final goal of the makina corpus team is to have our images using
<strong>systemd</strong> as the base command.</li>
<li>Indeed, nowadays, systemd is an extremly if not the most powerful linux too
l to manage all the lifecycle of processes and the ditch that they can leave
behind on the behalf of the underlying packagers work. So why, afterall
preventing us from using all the packaging by running only one process ?
We are on an <strong>UNIX Like OS</strong> guys...</li>
<li>In other words, There all the reasons to eat the <strong>microservice pattern</strong>, but
there is also no reason to eat the <strong>1 process for all soup</strong>.</li>
<li>We refuse here to hack some stuff around an alternative process manager,
we want to use the underlying distro as it was packaged.</li>
<li>makina-states is sufficiently flexible to run in all kind of modes, including
a docker container, running <strong>systemd</strong> or <strong>not</strong>, <strong>with</strong> or <strong>WITHOUT</strong>
<code class="docutils literal"><span class="pre">makina-states</span></code>.
This docker can run in unprevileged mode,
but at the condition of bind-mounting /sys/fs/cgroup. Be sure to have the most
recent version of systemd under ubuntu-vivid, or <strong>journald</strong> wont start.</li>
<li>On the host You will also need a special apparmor profile,
which is provided by makina-states, see <code class="docutils literal"><span class="pre">localsettings/apparmor.sls</span></code> for details.</li>
<li>The build system is inspired from our more than 20 years or UNIX experience, from
gentoo to Docker land. One of the goals was to make the 4 core build steps
in bash and utterly flexibles and easy to override.</li>
</ul>
</div>
<div class="section" id="construct-a-base-docker-image-with-makina-states">
<h2>Construct a base docker image with makina-states<a class="headerlink" href="#construct-a-base-docker-image-with-makina-states" title="Permalink to this headline">¶</a></h2>
<div class="section" id="abstract">
<h3>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h3>
<p>We provide a pipeline of 4 small shell scripts that bootstrap a proper
build environment for systemd containers based on ubuntu from <strong>ground0</strong> to
<strong>mars</strong>.</p>
<p>Those shell script are responsible of executing those containers
and run inside a build procedure, which should in most case also include
a test(selfcheck) procedure. Upon a sucessful build, a candidate image
is taggued.</p>
<p>All what is need for most projects is to create the injected volumes and the
<strong>stage3.sh</strong> script and onwards, other script are somewhat <strong>core</strong> and have
merely no change to have any change needs.</p>
<p>All that the user has to do to initiate a build pipeline is:</p>
<blockquote>
<div><ul class="simple">
<li>Setup a docker daemon with makina-states &amp; a proper apparmor profile.</li>
<li>clone a copy of the makina-states repository to a location of your choise,
with of course plenty if space under that root.</li>
</ul>
</div></blockquote>
<p>All commands must then be executed from the root of the repository.</p>
</div>
<div class="section" id="layout">
<h3>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h3>
<p>What is good to remember is that it is just a collection of shell scripts, and
to modulate an image building, we provide environ variables and volumes from
a well known data directory, which we expose to the build containers.
Users have just to appropriate the <strong>stageN.sh</strong> scripts and the file layout
to get their projects into a contineous deployment pipeline:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>makina-states/     &lt;- checkout of makina-states
|- docker/
|  |- stage0.sh stage1.sh stage2.sh stage3.sh [...] &lt;- default build scripts
|- data/
   |- globalimage.xxx.yyy.xz &lt;- The OS base tarball (like a lxc container
   |                                                 export)
   |- image1/ (manual image)
   |  |
   |  |- injected_volumes/    &lt;- All what is beneath this level
   |      |- /srv/projects/foobar    will be commited as-is to the image1 image
   |      |- /bootstrap_scripts/
   |          |- Dockerfile.stage0
   |          |- stage0.sh        &lt;- build scripts used for image1
   |          |- stage1.sh           they are always overriden by latest
   |          |- stage2.sh           version of either corpus projects
   |          |- stage3.sh           or default ones (makina-states/docker)
   |
   |
   |- image2/ (image based on a git clone of a corpus based project)
      |
      |- myapp.{js, php, py} -&gt; various code sources files, your project
      |
      |- .git &lt;- as there is also a .salt folder, this signals that this image
      |          wants to build a corpus based project and will deploy the current
      |          changeset inside the image
      |
      |- injected_volumes/    &lt;- All what is beneath this level
      |   |- /srv/projects/foobar    will be commited as-is to the image1 image
      |   |- /bootstrap_scripts/
      |
      |- .salt/
              |- Dockerfile.stage0
              |- stage0.sh        &lt;- will override everything that is in
              |- stage1.sh           injected_volumes/bootstrap_scripts/
              |- stage2.sh
              |- stage3.sh
</pre></div>
</div>
</div>
<div class="section" id="design-the-full-order-of-operation">
<h3>DESIGN: The full order of operation<a class="headerlink" href="#design-the-full-order-of-operation" title="Permalink to this headline">¶</a></h3>
<p>As the makina-states images are based upon a funtionnal init system (systemd)
for operation.</p>
<p>To initiate a build, the user can:</p>
<ul class="simple">
<li>Maybe place a precompiled base image in in the <strong>DATA DIR</strong>.</li>
<li>Maybe populate <strong>injected_volumes</strong> in the <strong>DATA DIR</strong> for the particular
image we are building. Basically,
all what will be placed in <strong>&lt;DATADIR&gt;/$IMAGE/injected_volumes</strong> will
be copied as-is and commited to the final image.</li>
</ul>
<p>Their initial build is a bit tedious in sense that they need at least a <strong>3 steps build</strong>.
Hopefully, we provide a script which has batteries included for you.</p>
<p>The procedure will then almost initially look like:</p>
<ul>
<li><p class="first">Create a container which has the necessary environment to build the images.
This is <strong>Stage0</strong>. we expose here:</p>
<blockquote>
<div><ul class="simple">
<li>All the docker related environment (socket, cache, layers)</li>
<li>The top of the data dir inside <strong>/docker/data</strong></li>
<li>The image dir
inside <strong>/injected_volumes</strong>
and also in <strong>/docker/injected_volumes</strong> (to make them available during
stage1 build)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The <strong>Stage1</strong> step involves</p>
<blockquote>
<div><ul>
<li><p class="first">Launching a container on the behalf of any supported environment variables
and/or command line arguments.</p>
</li>
<li><p class="first">If <strong>MB_BASE</strong> is <strong>scratch</strong>, the build will create from an lxc template
and using <a class="reference external" href="https://docs.docker.com/articles/baseimages/#creating-a-simple-base-image-using-scratch">scratch image</a> as a base a <strong>baseimage-xxx-yyy.tar.gz</strong> tarball
(or reuse if existing). This is the <strong>OS base image</strong>.</p>
</li>
<li><p class="first">This file <strong>baseimage-xxx-yyy.tar.gz</strong> is store on the top of
the <strong>MS_DATA_DIR</strong> directory.</p>
</li>
<li><p class="first">From this image, we launch a new container, ensuring that all
relevant environment variables and volumes are re-exposed to this
<strong>stage2</strong> container.</p>
</li>
<li><p class="first">Inside the container, we now enter <strong>Stage2</strong> step and run the
<strong>stage2.sh</strong> script as this container boot command which does:</p>
<blockquote>
<div><ul>
<li><p class="first">Copy all the content of <strong>/docker/injected_volumes</strong> to <strong>/</strong> ensuring
the conservation of any <strong>POSIX ACL</strong>. This will of course
be commited as of your final image.</p>
</li>
<li><dl class="first docutils">
<dt>We are not using the <strong>ADD</strong> Dockerfile instruction for</dt>
<dd><p class="first last">stage1 because it does not conserve <strong>POSIX ACLS</strong>.
Those acls are heavily used in makina-states setups.</p>
</dd>
</dl>
</li>
<li><p class="first">Spawn an init as in <strong>PID=1</strong> (currently: <strong>systemd</strong>)</p>
</li>
<li><p class="first">Launch makina-states installation and refresh unless users
enable it via the <strong>MS_MAKINASTATES_BUILD_FORCE</strong> envionment
variable (set it to no empty string)</p>
</li>
<li><p class="first">Execute <strong>/docker/injected_volumes/bootstrap_scripts/stage3.sh</strong>
and so enter what we call <strong>stage3</strong>  which by default:</p>
<blockquote>
<div><ul class="simple">
<li>(RE)Install any corpus based project</li>
<li>May execute a basic test suite to test (only the build) that
everything is in place, but basically the <strong>stage3</strong> script
is in control from the user and the stage file that has
the more chance to be edited by users.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Save the <strong>POSIX acls</strong> back to <strong>/acls.txt</strong></p>
</li>
<li><p class="first">Mark the container to restore acls on next boot via touching <strong>/acls.restore</strong></p>
</li>
<li><p class="first">If all the build is sucessfull, commit this container
as an image taggued with the <strong>candidate</strong> keyword.</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="how-to">
<h3>How To<a class="headerlink" href="#how-to" title="Permalink to this headline">¶</a></h3>
<p>The entry point to this build system is <strong>docker/stage.py</strong>.</p>
<p>You can override any of the <strong>docker/stageX.sh</strong> scripts by looking and overriding
them to your needs.
For stages &gt; 0, Don&#8217;t edit them, but use the environment
variables or docker volumes (as stage0.sh arguments) to use your custom scripts.</p>
<p>In most cases, you certainly only:</p>
<blockquote>
<div><ul>
<li><p class="first">place files and directories inside <strong>DATADIR/&lt;image&gt;/injected_volumes</strong></p>
</li>
<li><p class="first">have to override <strong>DATADIR/&lt;image&gt;/injected_volumes/bootstrap_scripts/stage3.sh</strong>
to construct an image. The more convenient way is to drop a file at this
place:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>DATADIR/&lt;image&gt;/image_rootfs/bootstrap_scripts/stage3.sh
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>To build an image, you set environment variables, and then run</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>docker/stage.py <span class="o">[</span>ARGS<span class="o">]</span>
</pre></div>
</div>
<p>The scripts support those environment variables, in <strong>user facing order</strong>:</p>
<blockquote>
<div><dl class="docutils">
<dt>MS_IMAGE</dt>
<dd>Image tarball (like a base lxc container export)</dd>
<dt>MS_BASE</dt>
<dd>Stage 1 base image (either <a class="reference external" href="https://docs.docker.com/articles/baseimages/#creating-a-simple-base-image-using-scratch">scratch image</a> or a real image.
If stage1 is <strong>scratch</strong>, you need to provide a <strong>baseimage-$os-$release.tar.xz</strong>
tarball placed in the &#8220;data&#8221; volume.
or the script will fetch for you a basic ubuntu container using
lxc-utils. For those who dont know, <strong>scratch</strong> is a special
and empty image in the Docker speaking.</dd>
<dt>MS_IMAGE_DIR</dt>
<dd>Data volume dir to place image related files like stage scripts &amp; injected data
(default: $DATA_DIR/$MS_IMAGE)</dd>
<dt>MS_COMMAND</dt>
<dd>Command to use on the resulting image (<strong>/sbin/init</strong>)</dd>
<dt>MS_GIT_BRANCH</dt>
<dd>Branch for makina-states (<strong>stable</strong>)</dd>
<dt>MS_OS</dt>
<dd>OS (eg: ubuntu)</dd>
<dt>MS_OS_RELEASE</dt>
<dd>OS release (eg: vivid)</dd>
<dt>MS_GIT_URL</dt>
<dd>Url for <a class="reference external" href="https://github.com/makinacorpus/makina-states">makina-states</a></dd>
<dt>MS_DATA_DIR</dt>
<dd>Data volume dir to place the <strong>baseimage-$os-$release.tar.xz</strong> file (default: ./data)</dd>
<dt>MS_BASEIMAGE</dt>
<dd>Filename of the base image
(default: <strong>baseimage-$os-$release.tar.xz</strong>)</dd>
<dt>MS_STAGE0_TAG</dt>
<dd>Tag of the stage0 image, by default it will look like
<strong>makinacorpus/makina-states-ubuntu-vivid-stage0</strong></dd>
<dt>MS_DOCKERFILE_STAGE0</dt>
<dd>Path to a <strong>Stage0</strong> builder Dockerfile,
default to current makina-states one (<strong>docker/Dockerfile.stage0</strong>)</dd>
<dt>MS_DOCKER_ARGS</dt>
<dd>Any argument to give to the docker run call to the stage0 builder (None)</dd>
<dt>MS_DO_SNAPSHOT</dt>
<dd>Cleanup all sensible data before saving image (ssh keys, pillars &amp; so on).
set to empty string to disable</dd>
<dt>MS_DO_ACLS</dt>
<dd>Save POSIX Acls before saving image.
set to empty string to disable</dd>
<dt>MS_DO_PASSWORDS_RESET</dt>
<dd>reset all defined unix user passwords before commiting the image.
set to empty string to disable</dd>
</dl>
</div></blockquote>
<p>Read Only variables:</p>
<blockquote>
<div><dl class="docutils">
<dt>MS_STAGE1_NAME</dt>
<dd>Name of the stage1 container (use to mount volumes from host in stage2
and onwards)</dd>
<dt>MS_STAGE2_NAME</dt>
<dd>Name of the stage2 container  (used to commit the final image)</dd>
</dl>
</div></blockquote>
<p>Additionnaly, in stage1 (read-only):</p>
<blockquote>
<div><dl class="docutils">
<dt>MS_IMAGE_CANDIDATE</dt>
<dd>Tag of the Image to commit if the build is sucessful,
default to <strong>$MS_IMAGE:candidate</strong></dd>
</dl>
</div></blockquote>
<p>You can feed the image with preconfigured pillars &amp; project trees
by creating files inside for example:</p>
<blockquote>
<div><ul class="simple">
<li><strong>&lt;DATADIR&gt;/&lt;IMAGE_NAME&gt;/image_rootfs/srv/pillar</strong></li>
<li><strong>&lt;DATADIR&gt;/&lt;IMAGE_NAME&gt;/image_rootfs/srv/mastersalt-pillar</strong></li>
<li><strong>&lt;DATADIR&gt;/&lt;IMAGE_NAME&gt;/image_rootfs/srv/projects</strong></li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Technically:</dt>
<dd><ul class="first last simple">
<li>all what is behind <strong>/docker/injected_volumes</strong> is copied, via rsync
with ACL support to the <strong>root (/)</strong> of the image.</li>
<li>Any file or directory inside $IMAGEDIR/image_rootfs will override the same
file at the same place in the same level <strong>injected_volumes</strong> directory.
The folders are synced via rsync at build time.</li>
</ul>
</dd>
</dl>
<p><strong>docker/stage.py</strong> can also take any argument that will be used
in the docker run command. Any environment knob defined via CLI args will
override variable setted via environment variables.</p>
<p>Indeed, it is via this trick that you can influence the build system.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">MS_IMAGE</span><span class="o">=</span><span class="s2">&quot;mycompany/myimage&quot;</span>
docker/stage.py -v <span class="nv">$PWD</span>:/docker/data
</pre></div>
</div>
<p>If you do not want to use an empty base image (for example a prebuilt makina-states
image), you can use <strong>MS_BASE</strong> to indicate your base</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>mkdir data2
<span class="nb">export</span> <span class="nv">MS_BASE</span><span class="o">=</span><span class="s2">&quot;mycompany/myimage&quot;</span>
docker/stage.py -v <span class="nv">$PWD</span>/data2:/docker/data2
</pre></div>
</div>
<p>OR</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>docker/stage.py -e <span class="nv">MS_BASE</span><span class="o">=</span><span class="s2">&quot;mycompany/myimage&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="default-build-volumes">
<h3>Default build volumes<a class="headerlink" href="#default-build-volumes" title="Permalink to this headline">¶</a></h3>
<p>Those volumes are exposed in all container stages:</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>CONTAINER</td>
<td>HOST</td>
</tr>
<tr class="row-even"><td>/docker/data</td>
<td>$DATADIR</td>
</tr>
<tr class="row-odd"><td>/docker/injected_volumes</td>
<td>$DATADIR/$IMAGE/injected_volumes</td>
</tr>
<tr class="row-even"><td>/docker/makina-states</td>
<td>makina-states/</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="adding-data-files-to-commited-image">
<h2>Adding data files to commited image<a class="headerlink" href="#adding-data-files-to-commited-image" title="Permalink to this headline">¶</a></h2>
<p>Anything (file, dir, symlink) that is placed in the <strong>/docker/injected_volumes</strong>
image data directory will be commited with the image.
The files are copied before <strong>stage2</strong> execution, thus you have them available at build time in their real place inside the root of the conrainer.</p>
<p>Anything that is beyong the <strong>IMAGE_DIR</strong> is available through a volume
(mountpoint)  in the <strong>/docker/data</strong> path inside <strong>stage2</strong> and onwards.</p>
<p>All you have to do is to place what you want to go in your image in this location:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$DATADIR(/path/makinastates/data)/&lt;IMAGE&gt;/injected_volumes/&lt;stuff&gt;
</pre></div>
</div>
<p>For example, you will have to place your <strong>fic.txt</strong> in the &#8220;<strong>project2</strong> image in, that will live in /foo:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>/srv/mastersalt/makina-states/data/project2/injected_volumes/foo/fic.txt
</pre></div>
</div>
<p>The principal application is to inject your project code and it&#8217;s pillar configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>/srv/mastersalt/makina-states/data/project2/injected_volumes/srv/projects/project2/project/...
/srv/mastersalt/makina-states/data/project2/injected_volumes/srv/projects/project2/pillar/init.sls
</pre></div>
</div>
</div>
<div class="section" id="overriding-stage-scripts-the-low-level-and-manual-way">
<h2>Overriding stage scripts, the low level and manual way<a class="headerlink" href="#overriding-stage-scripts-the-low-level-and-manual-way" title="Permalink to this headline">¶</a></h2>
<p>Anything that is placed in the <strong>image_rootfs</strong> image data directory will override
contents which are placedt first in the <strong>/docker/injected_volumes</strong> directory.</p>
<p>The reasoning of this is to provide a simple mean to give custom stage scripts
while most users can still use default script files, and we still use the
last version of those script on a rolling release fashion.</p>
<p>For example, if you want to override for example the <strong>stage3</strong> script,
all you have to do is to place a script in the datadir, in this location:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>DATADIR/&lt;IMAGE&gt;/image_rootfs/bootstrap_scripts/&lt;stage&gt;
</pre></div>
</div>
<p>For example, you will have to place your <strong>stage3.sh</strong> brewed copy override the <strong>stage3</strong> in the <strong>project2</strong> image in:</p>
<p>Eg, for example, to customize stage3, you will have to place your <strong>stage3.sh</strong>
versions which overrides the default one like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>cp /srv/mastersalt/makina-states/docker/stage3.sh /srv/mastersalt/makina-states/data/mycy/p2/image_rootfs/bootstrap_scripts/stage3.sh
$ED /srv/mastersalt/makina-states/data/mycy/p2/image_rootfs/bootstrap_scripts/stage3.sh
</pre></div>
</div>
</div>
<div class="section" id="integration-with-corpus-projects-makina-people-read-this">
<h2>Integration with corpus projects (MAKINA PEOPLE, READ THIS)<a class="headerlink" href="#integration-with-corpus-projects-makina-people-read-this" title="Permalink to this headline">¶</a></h2>
<p>For corpus based projects based on git, it&#8217;s even more easier
The idea is that the root of the image is a clone from your git repo,
and is pushed back inside the built image.</p>
<p>This allow you to:</p>
<blockquote>
<div><ul class="simple">
<li>Build automatically images based on a corpus project</li>
<li>Place <strong>stage</strong> builder files inside your <strong>.salt</strong> directory</li>
</ul>
</div></blockquote>
<p>Please note that you can only deploy one project per image, which will be called
<strong>app</strong> by convention.</p>
<p>This can of course be only a small orchestration project that orchestrate
building of other project inside the image during the build, but it will
drastically simplify all the files you ll need to place in the injected folder
for the image assembler to grab them later in the build process.</p>
<p>Example:</p>
<p>You just have to clone your image code in the data folder in the data according
to the project repository, and the image name, eg for <strong>mycompany/project3</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>git clone http://goo/foo.git /srv/mastersalt/makina-states/data/mycompany/myproject3
</pre></div>
</div>
<ul>
<li><p class="first">Copy and arrange in there all additionnal files like pillars:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>/srv/mastersalt/makina-states/data/srv/projects/app/pillar/init.sls
</pre></div>
</div>
</li>
<li><p class="first">For custom stages, you just need to drop them inside your .salt folder.
For example, to customize the stage3,  you only need to drop a <strong>stage3.sh</strong>
inside your <strong>.salt</strong> folder alongside your codebase.</p>
</li>
<li><p class="first">Then build your image:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">MS_IMAGE</span><span class="o">=</span><span class="s2">&quot;mycompany/myproject3&quot;</span> <span class="o">/</span><span class="n">srv</span><span class="o">/</span><span class="n">mastersalt</span><span class="o">/</span><span class="n">makina</span><span class="o">-</span><span class="n">states</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">stage</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="initialise-a-basic-corpus-project-layout-from-the-stage-scripts">
<h2>Initialise a basic corpus project layout from the stage scripts<a class="headerlink" href="#initialise-a-basic-corpus-project-layout-from-the-stage-scripts" title="Permalink to this headline">¶</a></h2>
<p>To bring bacck everything to everyone, dockerized containers only need
what&#8217;s needed for the fixperms &amp; install steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>mkdir myproject
docker run --rm -ti  -v $PWD/myproject:/srv/projects/myproject makinacorpus/makina-states-ubuntu-vivid bash
salt-call --local mc_project.deploy app
exit
</pre></div>
</div>
<p>You will have all the neccessary files inside the myproject folder to include them
inside your code repository and hack them to apply your deployment rules.</p>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014 -&gt; 2017, Mathieu Le Marec Pasquet, Régis Leroy &amp; Makina Corpus folks.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>